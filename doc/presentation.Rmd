---
title: "Computational Methods for Principle Component Analysis"
author: "David (Daiwei) Zhang"
date: "November 10, 2017"
header-includes:
   - \usepackage{amsmath, amssymb, amsfonts}
   - \setbeamertemplate{navigation symbols}{}
output:
  beamer_presentation:
    theme: "AnnArbor"
    colortheme: "dolphin"
    fonttheme: "structurebold"
    fig_caption: false
    incremental: false
---

## Principle Component Analysis

- Ancestral history
    - Often a confounder for the association between genes and diseases
- Principle Component Analysis
    - Estimate and quantify ancestral history 
    - Used to eliminate bias caused by ancestral history
- How PCA works
    - Find the directions of the greatest variance
    - Intuitively, rotate the coordination system to fit the directions of the data
    - PCA in 3D (https://www.joyofdata.de/public/pca-3d/)

## PCA on the HGDP Dataset

- Plot by Chaolong Wang et. al.

![](pcaPlot_wangchaolong.png)



## Singular Value Decomposition
- SVD gives us everything we need for PCA
\[
\underset{p \times n}{X} = \underset{p \times n}{U} \; \underset{n \times n}{D} \; \underset{n \times n}{V^T}
\]
    - $p$: # Features (SNPs)
    - $n$: # Individuals
    - $U$: PCs
    - $D$: Diagonal matrix of standard deviations (descending)
    - $V$: PC scores
- Can also use eigen decomposition
\[
X^T X = VD^2V^T, \quad X X^T = U D^2 U^T
\]

## Prediction: Augment and Decompose (A&D)

- Reference group: $\underset{p \times n}{X}$
- New individual: $\underset{p \times 1}{y}$
- Augment & decompose: $\underset{p \times (n+1)}{\tilde{X}} = (X, y) = \tilde{U}\tilde{D}\tilde{V}^T$
- PC scores for the new individual: The last row of $\underset{(n+1) \times (n+1)}{\tilde{V}}$
- The standard way of doing PCA

## Improving A&D: Procrustes Analysis

- So far we have $X = UDV^T$ and $\tilde{X} = \tilde{U}\tilde{D}\tilde{V}^T$
- Define
\[
  \underset{n \times n}V =
  \begin{bmatrix}
    \underset{n \times k_1}{V_{\text{ref}}} & \text{Trash}
  \end{bmatrix}
  \quad \text{and} \quad
  \underset{(n+1) \times (n+1)}{\tilde{V}} =
  \begin{bmatrix}
    \underset{n \times k_2}{\tilde{V}_\text{ref}} & \text{Trash}\\
    \underset{1 \times k_2}{\tilde{V}_\text{stu}} & \text{Trash}\\
  \end{bmatrix}
\]
    - $k_1$: # PCs we need ($1 \leq k_1 \leq k_2 \ll n$)
- Look for a linear transformation $f(\tilde{V}_\text{ref}) = \tilde{V}_\text{ref}A + b$ that minimizes the "distance" between $f(\tilde{V}_\text{ref})$ and $V_\text{ref}$.
\[
  A, b = \underset{A, b}{\operatorname{arg\;min}}\; d(V_\text{ref}, \tilde{V}_{\text{ref}}A+b)
\]
    - e.g. $d(A,B) = [\sum_{i,j}(A-B)_{ij}^2]^\frac{1}{2}$
- Procrustes-transformed PC scores for the new individual
\[
\underset{1 \times k_1}{\tilde{V}_\text{pro}} = \tilde{V}_\text{stu} A + b
\]

## Prediction: Simple Projection

- A&D + Procrustes is implemented in the software TRACE
- Accurate (golden standard), but slow
- A different way to do PCA: Simple projection
- Once finish $X = UDV^T$ and have $y$:
\[
\underset{1 \times n}{V_\text{stu}} = y^T U D^{-1}
\]
- Fast but has a "shrinking" bias
    - PC scores are less in magnitude compared to TRACE
    - Shrinkage increases as $p/n \to \infty$

## TRACE Improved: Online SVD

- Recall in TRACE
\[
  \underset{n \times n}V =
  \begin{bmatrix}
    \underset{n \times k_1}{V_{\text{ref}}} & \text{Trash}
  \end{bmatrix}
  \quad \text{and} \quad
  \underset{(n+1) \times (n+1)}{\tilde{V}} =
  \begin{bmatrix}
    \underset{n \times k_2}{\tilde{V}_\text{ref}} & \text{Trash}\\
    \underset{1 \times k_2}{\tilde{V}_\text{stu}} & \text{Trash}\\
  \end{bmatrix}
\]
where $1 \leq k_1 \leq k_2 \ll n$.

- Only the first $k_2$ PCs are needed for Procrustes analysis
- Online SVD: Only calculate for the first $k_3$ columns of $V$ ($k_2 \leq k_3 \ll n$)
- Make TRACE much faster

## Online SVD Algorithm

\begin{enumerate}
\item Calculate $U_3 = X V_3 D_3^{-1}$,
  where $V_3$ is the first $k_3$ columns of $V$,
  and $D_3$ is the diagonal matrix of the first $k_3$ diagonal entries of $D$.
\item Calculate 
  \[
    L = U_3^T y \quad \text{and} \quad K = y^T H,
  \]
  where $H$ is the normalized  $y - U_3L$
\item Calculate $Q^T Q$, where
  \[
    Q = 
    \begin{bmatrix}
      D_3 & L \\
      0 & K
    \end{bmatrix}.
  \]
\item Apply eigendecomosition to $Q^T Q$ to get $Q^T Q = \ddot{V}_3 \ddot{D}^2_3 \ddot{V}^T_3$.
\item Calculate
  \[
    \tilde{V}_3 =
    \begin{bmatrix}
      V_3 & 0 \\
      0 & 1
    \end{bmatrix}
    \ddot{V}_3.
  \]
\end{enumerate}

## Simple Projection Improved: HDPCA

- Input
    - Eigenvalues of the reference matrix
    - PC scores predicted by simple projection
- Output
    - Magnitude and angle of the shrinkage
    - Adjusted PC scores
- Computational Complexity
    - Higher than simple projection, lower than TRACE

## Comparison of Computational Complexity

\begin{table} 
  \centering
  \begin{tabular}{|l|l|}
    \hline
    Method & Computational Complexity \\ 
    \hline
    TRACE & $\mathcal{O}[n^2 p + mn(p + n^2)]$ \\
    \hline
    Projection & $\mathcal{O}[n^2p + mkp]$ \\
    \hline
    Online TRACE & $\mathcal{O}[n^2 p + mk(p + kn)]$ \\
    \hline
    HDPCA Projection & $\mathcal{O}[n^2p + mkp]$ \\
    \hline
  \end{tabular}
\end{table}

- $p$: # SNPs
- $n$: # Reference individuals 
- $m$: # Study individuals 
- $k_3$: # PCs calculated in Online SVD

## Simulation Study

- GGS: Simulates populations migrating on a $H \times H$ grid
- Parameters for GGS
    - L: Number of loci in each genealogy. (Fixed to $1000$.)
    - G: Number of genealogies. (Equal to $p / L$)
    - H: Side length of the grid. (Fixed to $2$.)
    - c: Number of haploids at each cell of the grid. (Equal to $2n / K^2$ and $2m / H^2$)
    - M: Migration rate. (Fixed to 100)
- Setting for simulation
    - $p = 100,000$
    - Setting 1
        - $n = 600$
        - $m$: $\min = 1000$, $\max = 5000$, $\text{increment} = 500$ 
    - Setting 2
        - $n$: $\min = 1000$, $\max = 5000$, $\text{increment} = 500$ 
        - $m = 200$
        
## Results ($n = 600$, $m = 1000$)

![](..//data/cluster/ggsim/ggsim_100000_600_1000_2_1_100.pdf)

## Results ($n = 600$, $m = 3000$)

![](..//data/cluster/ggsim/ggsim_100000_600_3000_2_1_100.pdf)

## Results ($n = 1000$, $m = 200$)

![](..//data/cluster/ggsim/ggsim_100000_1000_200_2_1_100.pdf)

## Results ($n = 3000$, $m = 200$)

![](..//data/cluster/ggsim/ggsim_100000_3000_200_2_1_100.pdf)

## Runtimes

![](runtimes.pdf)
    
## Accuracy (Distance from Reference Centers)

![](err_refcenter.pdf)

## Accuracy (Distance from Online TRACE)

![](err_online.pdf)

## Conclusion

\begin{table} 
  \centering
  \begin{tabular}{|l|c|c|}
    \hline
    Method & Accuracy & Speed (wrt $n$)\\ 
    \hline
    TRACE & Golden Standard & Low ($\mathcal{O}[n^3]$) \\
    \hline
    Projection & Low (when $n \ll p$) & High ($\mathcal{O}[1]$) \\
    \hline
    Online TRACE & High & High ($\mathcal{O}[n]$) \\
    \hline
    HDPCA Projection & High & High ($\mathcal{O}[1]$) \\ 
    \hline
  \end{tabular}
\end{table}

Note: The computational complexity is for each new study individual and $p$ is assumed to be fixed.




